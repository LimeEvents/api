scalar DateTime
scalar Currency

type Query {
  order(id: ID!): Order
  orders(filter: OrderFilter, first: Int, last: Int, before: String, after: String): OrderConnection!
  orderStatistics(startDate: Int!, endDate: Int!, performerId: ID, locationId: ID, eventId: ID): OrderStatistic!
  inventory(eventId: ID!): Inventory
  stream(id: ID, first: Int, last: Int, before: String, after: String): OrderLogConnection
}

input OrderFilter {
  eventId: ID
  locationId: ID
}

type OrderStatistic {
  startDate: Int!
  endDate: Int!
  """ Total number of orders created """
  orders: Int!
  """ Total number of tickets sold """
  ticketsSold: Int!
  """ Total revenue """
  revenue: Currency!
  """ Number of tickets that have been refunded """
  refunded: Int!
  """ Total amount refunded """
  refundedAmount: Currency!
  """ Amount collected in fees """
  fees: Currency!
  """ Amount colllected for taxes """
  taxes: Currency!
}

type Mutation {
  createOrder(input: CreateOrderInput!): CreateOrderResponse
  chargeOrder(input: ChargeOrderInput!): ChargeOrderResponse
  refundOrder(input: RefundOrderInput!): RefundOrderResponse
  transferOrder(input: TransferOrderInput!): TransferOrderResponse
  reassignOrder(input: ReassignOrderInput!): ReassignOrderResponse
}
input CreateOrderInput {
  clientMutationId: ID!
  id: ID
  eventId: ID!
  tickets: Int!
}
type CreateOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input ChargeOrderInput {
  clientMutationId: ID!
  """ Order ID created from reserving tickets """
  id: ID!
  """ Customer Name """
  name: String!
  """ Customer Email """
  email: String!
  """ Payment token """
  source: String!
}
type ChargeOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input RefundOrderInput {
  clientMutationId: ID!
  id: ID!
  name: String!
}
type RefundOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input TransferOrderInput {
  clientMutationId: ID!
  from: ID!
  fromAmount: Int!
  to: ID!
  toAmount: Int!
}
type TransferOrderResponse {
  clientMutationId: ID!
  order: Order!
  fromInventory: Inventory!
  toInventory: Inventory!
}
input ReassignOrderInput {
  clientMutationId: ID!
  id: ID!
  to: String!
  from: String!
}
type ReassignOrderResponse {
  clientMutationId: ID!
  order: Order!
}

type Order implements Node {
  id: ID!
  eventId: ID!
  tickets: Int!

  amount: Currency!
  fee: Currency!
  taxes: Currency!

  refunded: Boolean!
  paid: Boolean!

  fingerprint: ID
  willcall: [ String! ]!
  billing: Billing
  created: DateTime!
}

type Billing {
  name: String!
  postalCode: String!
}

type Inventory {
  available: Int!
  sold: Int!
  reserved: Int!
  history(first: Int, last: Int, before: String, after: String): OrderLogConnection
}

type OrderConnection implements Connection {
  edges: [ OrderEdge! ]!
  pageInfo: PageInfo!
}

type OrderEdge implements Edge {
  cursor: String!
  node: Order!
}

type OrderLogConnection implements Connection {
  pageInfo: PageInfo!
  edges: [ OrderLogEdge! ]!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type OrderLogEdge implements Edge {
  cursor: String!
  node: Node!
}

type OrderLog implements Log & Node {
  id: ID!
  type: OrderLogType
  event: Inventory
  hash: String!
}

interface Node {
  id: ID!
}

interface Connection {
  pageInfo: PageInfo!
  edges: [ Edge! ]!
}

interface Edge {
  cursor: String!
  node: Node!
}

interface Log {
  id: ID!
  hash: String!
}

enum OrderLogType {
  # TicketsReserved
  OrderCreated
  OrderRefunded
  OrderReassigned
  OrderTransferred
}
