scalar DateTime
scalar Currency

type Query {
  order(id: ID!): Order
  orders(filter: OrderFilter, first: Int, last: Int, before: String, after: String): OrderConnection!
  orderStatistics(startDate: Int!, endDate: Int!, performerId: ID, locationId: ID, eventId: ID): OrderStatistic!
  inventory(eventId: ID!): Inventory
  stream(id: ID, first: Int, last: Int, before: String, after: String): OrderLogConnection
}

input OrderFilter {
  eventId: ID
  locationId: ID
}

type OrderStatistic {
  startDate: Int!
  endDate: Int!
  """ Total number of orders created """
  orders: Int!
  """ Total number of tickets sold """
  ticketsSold: Int!
  """ Total gross """
  gross: Currency!
  """ Total net """
  net: Currency!
  """ Number of tickets that have been refunded """
  refunded: Int!
  """ Total amount refunded """
  refundedAmount: Currency!
  """ Amount collected in fees """
  fees: Currency!
  """ Amount colllected for taxes """
  taxes: Currency!
}

type Mutation {
  createOrder(input: CreateOrderInput!): CreateOrderResponse
  chargeOrder(input: ChargeOrderInput!): ChargeOrderResponse
  refundOrder(input: RefundOrderInput!): RefundOrderResponse
  transferOrder(input: TransferOrderInput!): TransferOrderResponse
  reassignOrder(input: ReassignOrderInput!): ReassignOrderResponse
}
input CreateOrderInput {
  clientMutationId: ID!
  id: ID
  eventId: ID!
  tickets: Int!
}
type CreateOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input ChargeOrderInput {
  clientMutationId: ID!
  """ Order ID created from reserving tickets """
  id: ID!
  """ Customer Name """
  name: String!
  """ Customer Email """
  email: String!
  """ Payment token """
  source: String!
}
type ChargeOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input RefundOrderInput {
  clientMutationId: ID!
  id: ID!
  """ Number of tickets to refund. Defaults to whole order """
  tickets: Int
}
type RefundOrderResponse {
  clientMutationId: ID!
  order: Order!
  inventory: Inventory!
}
input TransferOrderInput {
  clientMutationId: ID!
  """ Order ID """
  id: ID!
  """ Event tickets are transferring to """
  eventId: ID!
  """ Amount of tickets to transfer """
  tickets: Int!
}
type TransferOrderResponse {
  clientMutationId: ID!
  sourceOrder: Order!
  destinationOrder: Order!
  sourceInventory: Inventory!
  destinationInventory: Inventory!
}
input ReassignOrderInput {
  clientMutationId: ID!
  id: ID!
  to: String!
  from: String!
}
type ReassignOrderResponse {
  clientMutationId: ID!
  order: Order!
}

type Order implements Node {
  id: ID!
  eventId: ID!
  tickets: Int!

  """ Price of all tickets """
  subtotal: Currency!
  """ Amount refunded """
  refunded: Currency!
  """ Fee paid """
  fee: Currency!
  """ Sales tax """
  taxes: Currency!
  """ Total charged to card """
  total: Currency!

  paid: Boolean!

  fingerprint: ID
  willcall: [ String! ]!

  created: DateTime!
  updated: DateTime!
}

type OrderItem {
  eventId: ID!
  quantity: Int!
}

type Inventory {
  available: Int!
  sold: Int!
  reserved: Int!
  capacity: Int!
}

type OrderConnection {
  edges: [ OrderEdge! ]!
  pageInfo: PageInfo!
}

type OrderEdge {
  cursor: String!
  node: Order!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

interface Node {
  id: ID!
}
